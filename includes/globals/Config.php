<?php
/**
 * Created by PhpStorm.
 * User: Mark
 * Date: 06.12.14
 * Time: 21:16
 */
require_once "Environment.php";
require_once "includes/system/io/format/FormatFactory.php";
require_once "includes/util/ArrayUtil.php";
/**
 * Class Config
 */
class Config {
    /**
     * @var Config
     */
    private static $instance = null;

    /**
     * @var null|array
     */
    private $data = null;

    /**
     *
     */
    private function __construct() {

    }

    /**
     * @param $config
     * @return array|mixed
     * @throws Exception
     */
    public function load($config) {
        if (!file_exists($config)) {
            throw new Exception ("config not found");
        }
        $pathInfo = pathinfo($config);
        $fileName = $pathInfo["basename"];
        $tmpFile = Environment::getTempFile($fileName, "config", "php");
        $injector = $this->getInjectorFunction();
        if (file_exists($tmpFile)) {
            $data = include($tmpFile);
        } else {
            $data = FormatFactory::load($config);
            if (isset($data["configs"])) {
                $configData = array();
                foreach($data["configs"] as $key => $config) {
                    $loaded = FormatFactory::load($pathInfo["dirname"] . "/{$config}");
                    $injector($loaded);
                    $configData = ArrayUtil::mergeRecursiveIntersectKeys($loaded, $configData);
                }
                $data = $configData;
            }
            $content = "<?php // Generated by AbstractFormat of file '{$fileName}'\n";
            $content .= "return " . var_export($data, true) . ";";
            file_put_contents($tmpFile, $content);
        }
        $this->data = (isset($data) && !empty($data)) ? $data : array();
        return $this->data;
    }

    /**
     * @return Config
     */
    public static function getInstance() {
        if (!isset(self::$instance)) {
            self::$instance = new Config();
        }
        return self::$instance;
    }

    /**
     * @param $key
     * @return bool
     */
    public static function has($key) {
        $config = self::getInstance();
        return is_array($config->data) ? isset($config->data[$key]) : false;
    }

    /**
     * @param $key
     * @return mixed
     */
    public static function get($key) {
        $config = self::getInstance();
        return $config->data[$key];
    }

    /**
     * @return array|null
     */
    public function getData() {
        return $this->data;
    }

    /**
     * Hier werden fest Variablen in die config injeziert.
     *
     * @return callable
     *
     * @author mregner
     */
    protected function getInjectorFunction() {
        $pattern = array(
            '~ROOT_PATH/~',
            '~INCLUDE_PATH/~',
            '~APPLICATION_PATH/~',
            '~TMP_PATH/~',
            '~HOST_NAME~',
        );
        $replacements = array(
            Environment::getRootPath(),
            Environment::getIncludePath(),
            Environment::getApplicationPath(),
            Environment::getTempPath(),
            Server::getServerName(),
        );
        $injector = function(&$config) use ($pattern, $replacements, &$injector) {
            foreach($config as $key => &$value) {
                if(is_array($value)) {
                    $injector($value);
                } else if(is_string($value)) {
                    $config[$key] = preg_replace($pattern, $replacements, $value);
                }
            }
        };
        return $injector;
    }

    /**
     * @param array $tree
     * @return array
     */
    public function find(array $tree) {
        $data = $this->getData();
        $findData = array();
        foreach ($tree as $value) {
            if (empty($findData)) {
                if (isset($data[$value])) {
                    $findData = $data[$value];
                }
            } else if (isset($findData[$value])) {
                $findData = $findData[$value];
            }
        }
        return $findData;
    }
} 